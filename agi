#!/bin/bash
#
# argbash.io template
#
# ARG_OPTIONAL_BOOLEAN([list],[l],[List all active invitations])
# ARG_OPTIONAL_BOOLEAN([accept-all],[a],[Accept all active invitations.  If off, interactive mode is used.])
# ARG_OPTIONAL_SINGLE([password],[p],[GitHub password or personal access token])
# ARG_POSITIONAL_SINGLE([github-user],[GitHub username],[])
# ARG_HELP([Accept GitHub Invitations])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate


die()
{
    local _ret=$2
    test -n "$_ret" || _ret=1
    test "$_PRINT_HELP" = yes && print_help >&2
    echo "$1" >&2
    exit ${_ret}
}


begins_with_short_option()
{
    local first_option all_short_options='laph'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_list="off"
_arg_accept_all="off"
_arg_password=


print_help()
{
    printf '%s\n' "Accept GitHub Invitations"
    printf 'Usage: %s [-l|--(no-)list] [-a|--(no-)accept-all] [-p|--password <arg>] [-h|--help] <github-user>\n' "$0"
    printf '\t%s\n' "<github-user>: GitHub username"
    printf '\t%s\n' "-l, --list, --no-list: List all active invitations (off by default)"
    printf '\t%s\n' "-a, --accept-all, --no-accept-all: Accept all active invitations.  If off, interactive mode is used. (off by default)"
    printf '\t%s\n' "-p, --password: GitHub password or personal access token (no default)"
    printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
    _positionals_count=0
    while test $# -gt 0
    do
        _key="$1"
        case "$_key" in
            -l|--no-list|--list)
                _arg_list="on"
                test "${1:0:5}" = "--no-" && _arg_list="off"
                ;;
            -l*)
                _arg_list="on"
                _next="${_key##-l}"
                if test -n "$_next" -a "$_next" != "$_key"
                then
                    { begins_with_short_option "$_next" && shift && set -- "-l" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
                fi
                ;;
            -a|--no-accept-all|--accept-all)
                _arg_accept_all="on"
                test "${1:0:5}" = "--no-" && _arg_accept_all="off"
                ;;
            -a*)
                _arg_accept_all="on"
                _next="${_key##-a}"
                if test -n "$_next" -a "$_next" != "$_key"
                then
                    { begins_with_short_option "$_next" && shift && set -- "-a" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
                fi
                ;;
            -p|--password)
                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                _arg_password="$2"
                shift
                ;;
            --password=*)
                _arg_password="${_key##--password=}"
                ;;
            -p*)
                _arg_password="${_key##-p}"
                ;;
            -h|--help)
                print_help
                exit 0
                ;;
            -h*)
                print_help
                exit 0
                ;;
            *)
                _last_positional="$1"
                _positionals+=("$_last_positional")
                _positionals_count=$((_positionals_count + 1))
                ;;
        esac
        shift
    done
}


handle_passed_args_count()
{
    local _required_args_string="'github-user'"
    test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
    test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
    local _positional_name _shift_for=$1
    _positional_names="_arg_github_user "

    shift "$_shift_for"
    for _positional_name in ${_positional_names}
    do
        test $# -gt 0 || break
        eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
        shift
    done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])


# if a password is specified, store it as ':' plus the password so we can use it in the user string for curl
__pw=
if test -n $_arg_password
    then 
        __pw=":$_arg_password"
fi

# the page number (GitHub breaks the inventory list into a set of pages)
page=1

declare -a RESPONSES  #an array of responses (there may be multiple pages of invitations)
while true;
do

    echo "curl -s -u $_arg_github_user$__pw \"https://api.github.com/user/repository_invitations?page=$page\""
    RESPONSE=$(curl -s -u $_arg_github_user$__pw "https://api.github.com/user/repository_invitations?page=$page")

    if [[ "$RESPONSE" =~ ^[^\[] ]]
    then
        # if the response doesn't start with a JSON array then something went wrong
        echo "Something went wrong.  Here's the cURL response:"
        echo $RESPONSE
        exit 1
    elif test ${#RESPONSE} -lt 5
    then
        # if we've reached the last page then we're done
        # (an empty page comes back as '[]' which is apparently of length 4)
        break
    else
        # if this page had data then add the response to our responses array
        RESPONSES[$((page-1))]="$RESPONSE"
        # increment the page counter
        page=$((page+1))
    fi

done

# Each element in the RESPONSES array is a JSON array.
# Here we make a JSON array-of-arrays that we can parse properly with python below
JOINED_RESPONSES=$(IFS=, ; echo "[${RESPONSES[*]}]")

# Parse the JSON into a set of lines of Invitation info using python
INVITATIONS=$(echo "$JOINED_RESPONSES" | \
    python -c "

import sys,json

responses = json.load(sys.stdin)

for r in responses:
    for i in r :

        print(\"Invitation #\" + str(i['id']) + \" (\" + i['repository']['full_name'] + \")\")

")

if test "" == "$INVITATIONS"
then
    echo "Nothing to do...exiting"
    exit 1
fi

# If we're accepting all, get confirmation first
auto_accept=false
if test $_arg_accept_all == "on"
then
    echo $INVITATIONS
    while true;
    do
        echo -n "You are about to accept ALL the above invitations.  Are you sure you want to continue? [Y]/[n]: "
        read -n 1 confirm </dev/tty
        echo
        if test $confirm == 'n'
        then
            echo
            echo "Ok then, maybe later..."
            exit 1
        elif test $confirm == 'Y'
        then
            auto_accept=true
            break
        else
            echo "Bad response...try again..."
        fi
    done
fi


while read -r line; do

    # The python script above generates lines of the format:
    # Invitation #<invitation_id> (<repository full name>)
    # Here we pull out the invitation id from each line for later use
    if [[ $line =~ Invitation[[:space:]]#([0-9]+) ]]
    then
        invitation_id=${BASH_REMATCH[1]}
    fi

    if test $_arg_list == "on" -a ! $auto_accept
    then 
        echo "$line"
    else
        # if we're not just listing the set of invitations, then ...
        while true;
        do
            if [[ $auto_accept ]]
            then
                user_response='a'
            else
                # get the user's desired action for the current invitation
                echo "$line"
                echo -n "[a]ccept/[s]kip/[d]ecline: "
                read -n 1 user_response </dev/tty
                echo
            fi

            if [[ $user_response == 'a' ]]
            then
                echo
                echo "ACCEPTING $line"
                echo "curl -u $_arg_github_user$__pw --request PATCH \"https://api.github.com/user/repository_invitations/$invitation_id\""
                curl -u $_arg_github_user$__pw --request PATCH "https://api.github.com/user/repository_invitations/$invitation_id"
                break
            elif [[ $user_response == 'd' ]]
            then
                echo
                # For declinations, confirm first
                while true;
                do
                    echo -n "Are you sure you want to decline? [Y]/[n]: "
                    read -n 1 confirm </dev/tty
                    echo
                    if [[ $confirm == 'Y' ]]
                    then
                        echo
                        echo "DECLINING $line"
                        echo "curl -u $_arg_github_user$__pw --request DELETE \"https://api.github.com/user/repository_invitations/$invitation_id\""
                        curl -u $_arg_github_user$__pw --request DELETE "https://api.github.com/user/repository_invitations/$invitation_id"
                        break 2
                    elif [[ $confirm == 'n' ]]
                    then
                        break
                    else
                        echo "Bad response...try again..."
                    fi
                done
            elif [[ $user_response == 's' ]]
            then
                echo
                echo "SKIPPING $line"
                break
            else
                echo "Bad response...try again..."
            fi
        done
        echo $'\n'
    fi
done <<< "$INVITATIONS"